<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# session

## Introduction
Session is used to initialtively or automatically manage and transmit context between goroutines.

## Index

- [Constants](<#constants>)
- [func BindSession\(s Session\)](<#BindSession>)
- [func Go\(f func\(\)\)](<#Go>)
- [func GoSession\(s Session, f func\(\)\)](<#GoSession>)
- [func SetDefaultManager\(m SessionManager\)](<#SetDefaultManager>)
- [func UnbindSession\(\)](<#UnbindSession>)
- [type ManagerOptions](<#ManagerOptions>)
- [type Session](<#Session>)
  - [func CurSession\(\) \(Session, bool\)](<#CurSession>)
- [type SessionCtx](<#SessionCtx>)
  - [func NewSessionCtx\(ctx context.Context\) \*SessionCtx](<#NewSessionCtx>)
  - [func NewSessionCtxWithTimeout\(ctx context.Context, timeout time.Duration\) \*SessionCtx](<#NewSessionCtxWithTimeout>)
  - [func \(self SessionCtx\) Disable\(\)](<#SessionCtx.Disable>)
  - [func \(self \*SessionCtx\) Get\(key interface\{\}\) interface\{\}](<#SessionCtx.Get>)
  - [func \(self \*SessionCtx\) IsValid\(\) bool](<#SessionCtx.IsValid>)
  - [func \(self SessionCtx\) WithValue\(key interface\{\}, val interface\{\}\) Session](<#SessionCtx.WithValue>)
- [type SessionID](<#SessionID>)
- [type SessionManager](<#SessionManager>)
  - [func NewSessionManager\(opts ManagerOptions\) SessionManager](<#NewSessionManager>)
  - [func \(self SessionManager\) BindSession\(id SessionID, s Session\)](<#SessionManager.BindSession>)
  - [func \(self SessionManager\) GC\(\)](<#SessionManager.GC>)
  - [func \(self SessionManager\) GetSession\(id SessionID\) \(Session, bool\)](<#SessionManager.GetSession>)
  - [func \(self SessionManager\) UnbindSession\(id SessionID\)](<#SessionManager.UnbindSession>)
- [type SessionMap](<#SessionMap>)
  - [func NewSessionMap\(m map\[interface\{\}\]interface\{\}\) \*SessionMap](<#NewSessionMap>)
  - [func NewSessionMapWithTimeout\(m map\[interface\{\}\]interface\{\}, timeout time.Duration\) \*SessionMap](<#NewSessionMapWithTimeout>)
  - [func \(self \*SessionMap\) Disable\(\)](<#SessionMap.Disable>)
  - [func \(self \*SessionMap\) Get\(key interface\{\}\) interface\{\}](<#SessionMap.Get>)
  - [func \(self \*SessionMap\) IsValid\(\) bool](<#SessionMap.IsValid>)
  - [func \(self \*SessionMap\) WithValue\(key interface\{\}, val interface\{\}\) Session](<#SessionMap.WithValue>)


## Constants

<a name="DefaultShardNum"></a>

```go
const (
    // DefaultShardNum set the sharding number of id->sesssion map for default SessionManager
    DefaultShardNum = 10

    // DefaultGCInterval set the GC interval for default SessionManager
    DefaultGCInterval = time.Duration(0)

    // DefaultEnableTransparentTransmitAsync enables TransparentTransmitAsync for default SessionManager
    DefaultEnableTransparentTransmitAsync = false
)
```

<a name="BindSession"></a>
## func [BindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L60>)

```go
func BindSession(s Session)
```

BindSession binds the session with current goroutine

<a name="Go"></a>
## func [Go](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L74>)

```go
func Go(f func())
```

Go calls f asynchronously and pass caller's session to the new goroutine

<a name="GoSession"></a>
## func [GoSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L84>)

```go
func GoSession(s Session, f func())
```

SessionGo calls f asynchronously and pass s session to the new goroutine

<a name="SetDefaultManager"></a>
## func [SetDefaultManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L49>)

```go
func SetDefaultManager(m SessionManager)
```

SetDefaultManager updates default SessionManager to m

<a name="UnbindSession"></a>
## func [UnbindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L69>)

```go
func UnbindSession()
```

UnbindSession unbind a session \(if any\) with current goroutine

Notice: If you want to end the session, please call \`Disable\(\)\` \(or whatever make the session invalid\) on your session's implementation

<a name="ManagerOptions"></a>
## type [ManagerOptions](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L26-L35>)

ManagerOptions for SessionManager

```go
type ManagerOptions struct {
    // EnableTransparentTransmitAsync enables transparently transmit
    // current session to children goroutines
    EnableTransparentTransmitAsync bool
    // ShardNumber is used to shard session id, it must be larger than zero
    ShardNumber int
    // GCInterval decides the GC interval for SessionManager,
    // it must be larger than 1s or zero means disable GC
    GCInterval time.Duration
}
```

<a name="Session"></a>
## type [Session](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L27-L36>)

Session represents a local storage for one session

```go
type Session interface {
    // IsValid tells if the session is valid at present
    IsValid() bool

    // Get returns value for specific key
    Get(key interface{}) interface{}

    // WithValue sets value for specific key，and return newly effective session
    WithValue(key interface{}, val interface{}) Session
}
```

<a name="CurSession"></a>
### func [CurSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/gls.go#L54>)

```go
func CurSession() (Session, bool)
```

CurSession gets the session for current goroutine

<a name="SessionCtx"></a>
## type [SessionCtx](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L40-L43>)

SessionCtx implements Session with context, which means children session WON'T affect parent and sibling sessions

```go
type SessionCtx struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>



```go
/**
 * Copyright 2023 ByteDance Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"context"
)

func ASSERT(v bool) {
	if !v {
		panic("not true!")
	}
}

func GetCurSession() Session {
	s, ok := CurSession()
	if !ok {
		panic("can't get current seession!")
	}
	return s
}

func main() {
	var ctx = context.Background()
	var key, v = "a", "b"
	var key2, v2 = "c", "d"
	var sig = make(chan struct{})
	var sig2 = make(chan struct{})

	// initialize new session with context
	var session = NewSessionCtx(ctx) // implementation...

	// set specific key-value and update session
	start := session.WithValue(key, v)

	// set current session
	BindSession(start)

	// pass to new goroutine...
	Go(func() {
		// read specific key under current session
		val := GetCurSession().Get(key) // val exists
		ASSERT(val == v)
		// doSomething....

		// set specific key-value under current session
		// NOTICE: current session won't change here
		next := GetCurSession().WithValue(key2, v2)
		val2 := GetCurSession().Get(key2) // val2 == nil
		ASSERT(val2 == nil)

		// pass both parent session and new session to sub goroutine
		GoSession(next, func() {
			// read specific key under current session
			val := GetCurSession().Get(key) // val exists
			ASSERT(val == v)

			val2 := GetCurSession().Get(key2) // val2 exists
			ASSERT(val2 == v2)
			// doSomething....

			sig2 <- struct{}{}

			<-sig
			ASSERT(GetCurSession().IsValid() == false) // current session is invalid

			println("g2 done")
			sig2 <- struct{}{}
		})

		Go(func() {
			// read specific key under current session
			val := GetCurSession().Get(key) // val exists
			ASSERT(v == val)

			val2 := GetCurSession().Get(key2) // val2 == nil
			ASSERT(val2 == nil)
			// doSomething....

			sig2 <- struct{}{}

			<-sig
			ASSERT(GetCurSession().IsValid() == false) // current session is invalid

			println("g3 done")
			sig2 <- struct{}{}
		})

		BindSession(next)
		val2 = GetCurSession().Get(key2) // val2 exists
		ASSERT(v2 == val2)

		sig2 <- struct{}{}

		<-sig
		ASSERT(next.IsValid() == false) // next is invalid

		println("g1 done")
		sig2 <- struct{}{}
	})

	<-sig2
	<-sig2
	<-sig2

	val2 := GetCurSession().Get(key2) // val2 == nil
	ASSERT(val2 == nil)

	// initiatively ends the session，
	// then all the inherited session (including next) will be disabled
	session.Disable()
	close(sig)

	ASSERT(start.IsValid() == false) // start is invalid

	<-sig2
	<-sig2
	<-sig2
	println("g0 done")

	UnbindSession()
}
```

</p>
</details>

<a name="NewSessionCtx"></a>
### func [NewSessionCtx](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L46>)

```go
func NewSessionCtx(ctx context.Context) *SessionCtx
```

NewSessionCtx creates and enables a SessionCtx

<a name="NewSessionCtxWithTimeout"></a>
### func [NewSessionCtxWithTimeout](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L57>)

```go
func NewSessionCtxWithTimeout(ctx context.Context, timeout time.Duration) *SessionCtx
```

NewSessionCtx creates and enables a SessionCtx, and disable the session after timeout

<a name="SessionCtx.Disable"></a>
### func \(SessionCtx\) [Disable](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L67>)

```go
func (self SessionCtx) Disable()
```

Disable ends the session

<a name="SessionCtx.Get"></a>
### func \(\*SessionCtx\) [Get](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L80>)

```go
func (self *SessionCtx) Get(key interface{}) interface{}
```

Get value for specific key

<a name="SessionCtx.IsValid"></a>
### func \(\*SessionCtx\) [IsValid](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L72>)

```go
func (self *SessionCtx) IsValid() bool
```

IsValid tells if the session is valid at present

<a name="SessionCtx.WithValue"></a>
### func \(SessionCtx\) [WithValue](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L88>)

```go
func (self SessionCtx) WithValue(key interface{}, val interface{}) Session
```

Set value for specific key，and return newly effective session

<a name="SessionID"></a>
## type [SessionID](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L79>)

SessionID is the indentity of a session

```go
type SessionID uint64
```

<a name="SessionManager"></a>
## type [SessionManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L43-L47>)

SessionManager maintain and manage sessions

```go
type SessionManager struct {
    // contains filtered or unexported fields
}
```

<a name="NewSessionManager"></a>
### func [NewSessionManager](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L59>)

```go
func NewSessionManager(opts ManagerOptions) SessionManager
```

NewSessionManager creates a SessionManager with default containers If opts.GCInterval \> 0, it will start scheduled GC\(\) loop automatically

<a name="SessionManager.BindSession"></a>
### func \(SessionManager\) [BindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L107>)

```go
func (self SessionManager) BindSession(id SessionID, s Session)
```

BindSession binds the session with current goroutine

<a name="SessionManager.GC"></a>
### func \(SessionManager\) [GC](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L141>)

```go
func (self SessionManager) GC()
```

GC sweep invalid sessions and release unused memory

<a name="SessionManager.GetSession"></a>
### func \(SessionManager\) [GetSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L83>)

```go
func (self SessionManager) GetSession(id SessionID) (Session, bool)
```

Get gets specific session or get inherited session if option EnableTransparentTransmitAsync is true

<a name="SessionManager.UnbindSession"></a>
### func \(SessionManager\) [UnbindSession](<https://github.com/bytedance/gopkg/blob/develop/util/session/manager.go#L123>)

```go
func (self SessionManager) UnbindSession(id SessionID)
```

UnbindSession clears current session

Notice: If you want to end the session, please call \`Disable\(\)\` \(or whatever make the session invalid\) on your session's implementation

<a name="SessionMap"></a>
## type [SessionMap](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L98-L102>)

NewSessionMap implements Session with map, which means children session WILL affect parent session and sibling sessions

```go
type SessionMap struct {
    // contains filtered or unexported fields
}
```

<a name="NewSessionMap"></a>
### func [NewSessionMap](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L105>)

```go
func NewSessionMap(m map[interface{}]interface{}) *SessionMap
```

NewSessionMap creates and enables a SessionMap

<a name="NewSessionMapWithTimeout"></a>
### func [NewSessionMapWithTimeout](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L116>)

```go
func NewSessionMapWithTimeout(m map[interface{}]interface{}, timeout time.Duration) *SessionMap
```

NewSessionCtx creates and enables a SessionCtx, and disable the session after timeout

<a name="SessionMap.Disable"></a>
### func \(\*SessionMap\) [Disable](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L134>)

```go
func (self *SessionMap) Disable()
```

Disable ends the session

<a name="SessionMap.Get"></a>
### func \(\*SessionMap\) [Get](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L139>)

```go
func (self *SessionMap) Get(key interface{}) interface{}
```

Get value for specific key

<a name="SessionMap.IsValid"></a>
### func \(\*SessionMap\) [IsValid](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L126>)

```go
func (self *SessionMap) IsValid() bool
```

IsValid tells if the session is valid at present

<a name="SessionMap.WithValue"></a>
### func \(\*SessionMap\) [WithValue](<https://github.com/bytedance/gopkg/blob/develop/util/session/session.go#L150>)

```go
func (self *SessionMap) WithValue(key interface{}, val interface{}) Session
```

Set value for specific key，and return itself

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
